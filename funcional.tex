\section{Paradigma Funcional}

\subsection{Características generales}

\begin{itemize}
  \item Computación expresada a través de la aplicación y composición de funciones.
  \item No hay un estado global.
  \item Los estados intermedios (salidas de las funciones) son pasados directamente a otras funciones como argumentos.
  \item Repetición basada en recursión.
  \item Expresiones tipadas.
  \item Tine un \xbf{alto nivel de abstracción}: tiende a ser una \xit{especificación ejecutable}.
  \item Es \xbf{declarativo}: la máquina se encarga de buscar el \xit{cómo} y nosotros elegimos el \xit{qué}.
  \item La matemática y razonamiento algebraico tienden a ser más elegantes.
  \item En el pasado: ejecución más lenta. Hoy en día no está tan claro que sea así.
\end{itemize}

\subsection{Fundamentos}

\begin{itemize}
  \item Se enfoca en la transformación de la información, y no tanto en la interación con el medio.
  \item \xbf{Valores:} entidades (matemáticas) abstractas con ciertas propiedades.
  \item \xbf{Expresiones:} cadenas de símbolos utilizadas para denotar valores. Se dividen en:
    \begin{itemize}
      \item Atómicas: llamadas también formas normales. Ejemplo: \xtt{2, False, (3, True)}.
      \item Compuestas: se \xit{arman} combinando subexpresiones. Ejemplo: \xtt{(1+1), (2==1)}.
    \end{itemize}
  \item \xbf{Funciones:} son valores especiales que representan ``transformaciones de datos''. Notese que al ser valores, pueden ser argumento de otras funciones, resultado, almacenarse en estructuras de datos, ser estructuras de datos, etc. Llamamos funciones de \xbf{alto orden} a las funciones que trabajan con funciones.
  \item \xbf{Transparencia referencial:} el valor de una expresión depende sólo de los elementos que la constituyen. Esto implica, por ejemplo, que los detalles de ejecución no influencían el comportamiento del programa. Además, existe la posibilidad de demostrar propiedades usando las propiedades de las subexpresiones y métodos de deducción lógica.
  \item \xbf{Programa funcional:} es un conjunto de ecuaciones que definen una o más funciones. Para usarlo, resolvemos la reducción de la aplicación de una función a sus datos (reducción de una expresión).
\end{itemize}

Decimos que un \xbf{Lenguaje funcional puro} es aquel que es un ``lenguaje de expresiones con transparencia referencial y funciones como valores, cuyo modelo de cómputo es la reducción realizada mediante el remplazo de iguales por iguales''.

\subsection{Tipos}

Toda expresión válida denota un valor. Además, todo valor pertenece a un conjunto, y los tipos denotan conjuntos.
Es decir, toda expresión debería tener un tipo para ser válida.

\paragraph{Inferencia de tipos:} dada una expresión \xtt{e}, determinar si tiene tipo o no según las reglas, y cuál es ese tipo.

\paragraph{Chequeo de tipos:} dada una expresión \xtt{e} y un tipo \xtt{A}, determinar si \xtt{e} tipa \xtt{A} (\xtt{e :: A}) según las reglas, o no.

\paragraph{Sistema de tipado fuerte (string typing):} acepta una expresión si, y solo si, ésta tiene tipo según las reglas.

\paragraph{Sistema de Hindley-Milner} es un sistema de tipos que propone:

\begin{itemize}
  \item Tipos básicos:
    \begin{itemize}
      \item Enteros: \xtt{Int}
      \item Caracteres: \xtt{Char}
      \item Booleanos: \xtt{Bool}
    \end{itemize}
  \item Tipos compuestos:
    \begin{itemize}
      \item Tuplas: \xtt{(A,B)}
      \item Listas: \xtt{[A]}
      \item Funciones: \xtt{(A -> B)}
    \end{itemize}
  \item \xbf{Polimorfismo:} permite que una expresión tenga más de un sólo tipo. El polimorfismo paramétrico soluciona esto usando \xbf{variables de tipos}, ejemplo: \xtt{id :: a -> a}.
\end{itemize}

\subsection{Currificación}

Establece una correspondencia entre cada función de múltiples parámetros y una de alto orden que retorna una función intermedia que completa el trabajo. Es decir, por cada \xtt{f'} definida como:
\begin{lstlisting}[language=Haskell]
f' :: (a,b) -> c
f' (x,y) = e
\end{lstlisting}

siempre se puede escribir

\begin{lstlisting}[language=Haskell]
f :: a -> (b -> c)
(f x) y = e
\end{lstlisting}

O sea, que hay una correspondencia entre los tipos \xtt{(a,b) -> c} y \xtt{a -> (b -> c)}. Y se pueden hacer funciones \xtt{curry :: ((a,b) -> c) -> (a -> (b -> c))} y \xtt{uncurry :: (a -> (b -> c)) -> ((a,b) -> c)} que transformen funciones de un tipo al otro.

\xit{Nota:} tener en cuenta que decir si algo está currificado o no puede ser una cuestión de interpretación. El ejemplo canónico es la función \xtt{distance :: (Int, Int) -> Int} que calcula la distancia euclidea de un punto al origen. Uno podría querer currificar el primer parámetro, pero entonces quizás sería menos obvio que la función espera un punto.

\subsection{Haskell}

\subsubsection{Repaso}

\begin{itemize}
  \item La evaluación consiste en aplicar ecuaciones (orientadas de izquierda a derecha).
  \item Definición de funciones por casos.
  \item Tipos básicos: \xtt{Int}, \xtt{Bool}, \xtt{Float}, \xtt{Pares}, \xtt{Listas}, \xtt{Funciones}, etc.
  \item No toda evaluación termina.
  \item Utiliza evaluación \xit{Lazy o Normal}: una subexpresión se evalua sólo si es necesario.
  \item Polimorfismo párametrico.
  \item Alto orden
  \item Currificación
\end{itemize}

\subsubsection{Esquemas de recursion}

\subsubsection{Tipos algebraicos}

\subsubsection{Pattern matching}

\subsubsection{Monadas}

Una mónada es un tipo paramétrico \xtt{M a} con operaciones

\begin{lstlisting}[language=Haskell]
return :: a -> M a
(>>=) :: M a -> (a -> M b) -> M b
\end{lstlisting}

que satisfacen las siguientes leyes

\begin{lstlisting}[language=Haskell]
return x >>= k              = k x
m >>= \x -> return x        = m
m >>= \x -> (n >>= \y -> p) = (m >>= \x -> n) >>= \y -> p
    (siempre que x no aparezca en p)
\end{lstlisting}

El objetivo de la Mónada es incorporar \xit{efectos} a un valor.
\begin{itemize}
  \item El tipo \xtt{M a} incorpora la información necesaria.
  \item \xtt{return x} representa a \xtt{x} con \xit{efecto nulo}.
  \item \xtt{($>>=$)} \xit{secuencia} efectos con \xit{dependencia} de datos.
\end{itemize}

Es una forma de abstraer comportamientos específicos en un cómputo. Cada mónaad se diferencia de las demás por sus operaciones adicionales:
\begin{itemize}
  \item \xtt{Maybe} tiene \xtt{fail}
  \item \xtt{State} tiene \xtt{incrementar}
  \item \xtt{Output} tiene \xtt{imprimir}
  \item etc.
\end{itemize}

Haskell define una clase para las mónadas

\begin{lstlisting}[language=Haskell]
class Monad m where
  return :: a -> m a
  (>>=) :: m a -> (a -> m b) -> m b
\end{lstlisting}

Por ejemplo, para definir \xtt{Maybe} como una mónada se escribe

\begin{lstlisting}[language=Haskell]
instance Monad Maybe where
  return x = Just x
  m >>= k = case m of
    Nothing -> Nothing
    Just x -> k x
\end{lstlisting}

\paragraph{Funciones generales}

Pueden definirse muchas funciones de uso general usando sólo la interfase de mónadas
\begin{lstlisting}[language=Haskell]
liftM :: Monad m => (a -> b) -> m a -> m b
liftM f mx = do
  x <- mx
  return (f x)

liftM2 :: Monad m => (a -> b -> c) -> m a -> m b -> m c
liftM2 f mx my = do x <- mx
  y <- my
  return (f x y)
\end{lstlisting}

Estas funciones pueden usarse para definir funciones específicas para la aplicación, por ejemplo:

\begin{lstlisting}[language=Haskell]
(</>) :: Monad m => m Float -> m Float -> m Float
(</>) = liftM2 (/)

eval :: Monad m => E -> m Float
eval (Cte n) = return n
eval (Div e1 e2) = eval e1 </> eval e2
\end{lstlisting}

\subsection{Lambda cálculo}

Fue introducido por \xit{Alonzo Church} en 1934, y presenta un modelo de comptuación basado en \xbf{funciones}.

La formulación original es sin tipos, pero posteriormente (1941) se introduce el \xbf{Lambda cálculo tipado}, que es el que vamos a estudiar.

Empezamos con el Lambda cálculo tipado con expresiones booleanas y luego lo vamos extendiendo con otras construcciones.

\subsubsection{Expresiones de tipos}

Denotan los diferentes \xbf{tipos}. Por ejemplo, en el Lambda cálculo tipado con expresiones booleanas (de ahora en más $\lambda^b$) tenemos:

\[ \sigma, \tau ::= Bool|\sigma\to\tau \]

dónde,
\begin{itemize}
  \item $Bool$ es el tipo de los booleanos,
  \item $\sigma\to\tau$ es el tipo de las funciones de tipo $\sigma$ en $\tau$,
  \item con $\sigma$ y $\tau$ dos tipos (no necesariamente distintos).
\end{itemize}

\subsubsection{Términos}

Denotan las posibles expresiones que podemos construir. Por ejemplo, en $\lambda^b$ tenemos:

\[ M ::= true \vert false \vert \ifte{M}{P}{Q} \vert \app{M}{N} \vert \abs{x}{\sigma}{M} \vert x \]

dónde,
\begin{itemize}
  \item $true$ y $false$ son las constantes de verdad,
  \item \ifte{M}{P}{Q} es el condicional,
  \item \app{M}{N} es la aplicación de la función denotada por el término $M$ al argumento $N$,
  \item \abs{x}{\sigma}{M} es una función cuyo parámetro formal es $x$ y cuyo cuerpo es $M$.
  \item $x$ es una variable de términos.
\end{itemize}

Ejemplo: $\app{(\abs{f}{Bool \to Bool}{f\ true})}{(\abs{y}{Bool}{y})}$

\subsubsection{Sustitución}

Dentro de un término, una variable puede estar \xbf{libre} o \xbf{ligada}. Decimos que $x$ ocurre libre si no se encuentra bajo el alcance de una ocurrencia de $\lambda x$. En caso contrario, está ligada. Formalmente, tenemos que:

\begin{align*}
FV(x) &\eqdef \{x\} \\
FV(true) = FV (false) &\eqdef \emptyset \\
FV(\ifte{M}{P}{Q}) &\eqdef FV(M) \cup FV(P) \cup FV(Q) \\
FV(\app{M}{N}) &\eqdef FV(M) \cup FV(N) \\
FV(\abs{x}{\sigma}{M}) &\eqdef FV(M)\ \backslash\ \{x\} \\
\end{align*}

Luego, el proceso de sustitución $M\{x \from N\}$ consiste en sustituir todas las ocurrencias \xit{libres} de $x$ en el término $M$ por el término $N$. Esto se utilizar para darle semántica a la aplicación de funciones.

Cuando realizamos este proceso, asumimos que la variable ligada se renombró de tal manera que no ocurre libre en $N$. Por ejemplo:

\[ \sust{\abs{z}{\sigma}{x}}{x\from Z} = \abs{z}{\sigma}{z}\]

Está mal, ya que convertimos la función constante \abs{z}{\sigma}{x} en la función identidad. Entonces, deberíamos haber utilizado:

\[ \sust{\abs{w}{\sigma}{x}}{x\from Z} = \abs{w}{\sigma}{z}\]

Una vez que entendemos esto, podemos definir el concepto de $\alpha-equivalencia$. Decimos que dos términos $M$ y $N$ son $\alpha-equivalentes$ si difieren solamente en el nombre de sus variables ligadas. Ejemplo: $\abs{z}{Bool}{z} =_{\alpha} \abs{y}{Bool}{y}$, pero $\abs{x}{Bool}{y} \neq_{\alpha} \abs{x}{Bool}{z}$.

En los casos de sustitución que haya conflictos, podemos renombrar apropiadamente para que ande todo.

\subsubsection{Sistema de tipado}

Es un sistema formal de deducción (o derivación) que utiliza axiomas y reglas de tipado para caracterizar un subconjunto de los términos llamados \xit{tipados}. Es decir, es un sistema mediante el cual podemos deducir el tipo de un término.

Un \xit{contexto de tipado} $\Gamma$ es un conjunto de pares $\{x_1:\sigma_1,\dots,x_n:\sigma_n\}$ donde cada $x_i$ es distinto. Los $x_i$ representan las variables y los $\sigma_i$ sus tipo asignado.

Un \xit{juicio de tipado} es una expresión de la forma $\Gamma \rhd M : \sigma$ que significa que el término $M$ tiene tipo $\sigma$ asumiendo el contexto de tipado $\Gamma$. Estos juicios se generan utilizando \xit{axiomas y reglas de tipado}. Ejemplo de axioma:

\[\deriv{}{\Gamma \rhd true : Bool}{T-True}\]

Ejemplo de regla:

\[\deriv{\Gamma, x : \sigma \rhd M : \tau}{\Gamma \rhd \abs{x}{\sigma}{M}:\sigma\to\tau}{T-Abs}\]

\vspace{0.5em}
Entonces, $M$ es \xit{tipable}  si $\Gamma \rhd M : \sigma$ puede derivarse usando los axiomas y reglas de tipados, para algún $\Gamma$ y $\sigma$.

\paragraph{Propiedades básicas:}

\begin{itemize}
  \item \xbf{Unicidad de tipos}: si $\Gamma \rhd M : \sigma$ y $\Gamma \rhd M : \tau$ son derivables, entonces $\sigma = \tau$.
  \item \xbf{Weakening+Strenghening}: si $\Gamma \rhd M : \sigma$ es derivable y $\Gamma \cap \Gamma'$ contiene a todas las variables libres de $M$, entonces $\Gamma' \rhd M : \sigma$.
  \item \xbf{Sustitución}: si $\Gamma,x:\sigma \rhd M : \tau$ y $\Gamma \rhd N : \sigma$ son derivables, entonces $\Gamma \rhd \sust{M}{x\from N} : \tau$ es derivable.
\end{itemize}

\subsubsection{Semántica operacional}

Habiendo definido la sintaxis de $\lambda^b$, nos interesa formular cómo se evalúan o ejecutan los términos. Esto se puede hacer de varias formas: operacional, denotacional y axiomática. Nosotros vamos a user \xit{operacional}.

La semántica operacional consiste en interpretar a los \xit{términos como estados} de una máquina abstracta y definir una \xit{función de transición} que indica, dado un estado, cúal es el estado siguiente. De esta forma, el \xit{significado} de un término $M$ es el estado final que alcanza la máquina empezando desde $M$. Hay principalmente dos formas de definir la función de transición:

\begin{itemize}
  \item \xbf{Small-step}: la función de transición describe un paso de computación.
  \item \xbf{Big-step}: la función de transición, en un paso, evalúa el término a su resultado.
\end{itemize}

Al igual que con el Sistema de tipado, vamos a usar axiomas y reglas para formular \xbf{juicios de evaluación} $M\to N$ que indican que el término $M$ reduce, en un paso, al término $N$. Ejemplo de axioma:

\[\deriv{}{\ifte{true}{M_2}{M_3} \to M_2}{E-IfTrue}\]

Ejemplo de regla:

\[\deriv{M_1 \to M_1'}{\ifte{M_1}{M_2}{M_3} \to \ifte{M_1'}{M_2}{M_3}}{E-If}\]

Cuando dado un término $M$, no existe $N$ tal que $M\to N$, decimos que $M$ no puede reducirse más y está en \xbf{forma normal}.

Lo último que nos falta agregar es un conjunto de \xbf{Valores} que denota las expresiones que pueden ser un resultado válido de un cómputo. Para $\lambda^b$, tenemos que $V ::= true \vert false$.

\paragraph{Propiedades básicas:}

\begin{itemize}
  \item \xbf{Determinismo del juicio de evaluación en un paso}: si $M \to M'$ y $M \to M''$, entonces $M'= M''$.
  \item Todo valor está en forma normal, pero no vale el recíproco.
  \item Si un termino está en forma normal pero no es un valor, entonces decimos que es un \xbf{estado de error}.
\end{itemize}

\noindent
El \xbf{Juicio de evaluación en muchos pasos} $\toto$ es la clausura reflexiva, transitiva de $\to$. Es decir, la menor relación tal que:

\begin{itemize}
  \item Si $M\to M'$, entonces $M\toto M'$.
  \item $M\toto M$, para todo $M$.
  \item Si $M \toto M'$ y $M' \toto M''$, entonces $M \toto M''$.
\end{itemize}

\paragraph{Propiedades de evaluación en muchos pasos:}

\begin{itemize}
  \item \xbf{Unicidad de formas normales}: si $M \toto _U$ y $M \toto V$, entonces $U=V$.
  \item \xbf{Terminación}: para todo $M$ existe una forma normal $N$ tal que $M \toto N$.
  \item Si un término está bien tipado, y termina, entonces evalúa a un valor.
\end{itemize}

\paragraph{Propiedades de \xit{Corrección}:}

\begin{itemize}
  \item Corrección = Progreso + Preservación.
  \item \xbf{Progreso}: si $M$ es cerrado y bien tipado entonces
    \begin{itemize}
      \item $M$ es un valor
      \item o bien existe $M'$ tal que $M \to M'$.
    \end{itemize}
    Esto quiere decir que la evaluación no puede trabarse para términos cerrados y bien tipados que no son valores.
  \item \xbf{Preservación}: si $\Gamma \rhd M : \sigma$ y $M \to N$, entonces $\Gamma \rhd N : \sigma$. Es decir que la evaluación preserva tipos.
\end{itemize}

\subsubsection{Extensiones}

\begin{itemize}
  \item $\lambda^{bn}$: tiene $Bool$, $Nat$ y funciones.
  \item Registros
  \item Declaraciones locales
  \item Referencias
  \item Recursión
\end{itemize}

\subsubsection{Inferencia de tipos}

Es un procedimiento que consiste en transformar términos \xit{sin} información de tipos en términos \xbf{tipables}. Para ello, debemos inferir la información de tipos faltante. Esto trae como beneficios:

\begin{itemize}
  \item El programador puede obviar algunas declaraciones de tipos.
  \item En general, evita la sobrecarga de tener que declarar y manipular \xit{todos} los tipos.
  \item Todo ello sin impactar la perfomance del programa: la inferencia de tipos se realiza en tiempo de compilación.
\end{itemize}

\paragraph{Función de borrado}

LLamamos \erase{\cdot} a la función que dado un término \xit{elimina} las anotaciones de tipos de las abstracciones. Ejemplo: $\erase{\abs{x}{Nat}{\abs{f}{Nat\to Nat}{f\ x}}} = \stabs{x}{\stabs{f}{f\ x}}$

Entonces queremos, dado un término $U$ \xit{sin} anotaciones de tipos, hallar un término estándar $M$ tal que:
\begin{itemize}
  \item $\Gamma \rhd M : \sigma$, para algún $\Gamma$ y $\sigma$, y
  \item $\erase{M} = U$
\end{itemize}

Notar que este problema es más difícil que el chequeo de tipos para un término estandar $M$ que haciamos utilizando los axiomas y reglas del sistema de tipado.

\paragraph{Variables de tipos}

Para poder escribir una \xit{única} expresión que englobe muchas soluciones de inferencia vamos a usar variables de tipo.

Dichas variables las vamos a representar con la letra ``\xit{s}''. Si tenemos una expresión que utiliza \xit{s}, basta con sustituir \xit{s} por cualquier expresión de tipos para arrojar una solución válida.

\paragraph{Sustitución de tipos}

Es una función $S$ o $T$ que mapea variables de tipo en expresiones de tipo. Entonces, nuestra función de sustitución $S$ puede aplicarse a:
\begin{itemize}
  \item Una expresión de tipos $\sigma$ (escribimos $S\sigma$)
  \item Una término $M$ $\sigma$ (escribimos $SM$)
  \item Un contexto de tipado  $\Gamma = \{x_1:\sigma_1,\dots,x_n:\sigma_n\}$ (escribimos $S\Gamma$) y se define como $S\Gamma \eqdef \{x_1:S\sigma_1,\dots,x_n:S\sigma_n\}$
\end{itemize}

Notas sobre la sustitución:

\begin{itemize}
  \item El conjunto $\{t\ |\ St \neq t\}$ se llama \xbf{soporte} de $S$. Este conjunto representa las variables que $S$ ``afecta''.
  \item Usamos la notación $\{\sigma_1/t_1,\dots,\sigma_n/t_n\}$ para la sustitución con soporte $\{t_1,\dots,t_n\}$.
  \item La sustitución cuyo soporte es $\emptyset$ es la sustitución identidad (\xit{Id}).
\end{itemize}

\paragraph{Instancia de un juicio de tipado}

Un juicio de tipado $\Gamma' \rhd M' : \sigma'$ es una instancia de $\Gamma \rhd M : \sigma$ si existe una substitución de tipos $S$ tal que $S\Gamma \subset \Gamma'$, $M' = SM$ y $\sigma' = S\sigma$. Como propiedad: si $\Gamma \rhd M : \sigma$ es derivable, entonces cualquier instancia del mismo también lo es.

\paragraph{Función de inferencia \w{\cdot}}

Entonces, queremos definir una función \w{\cdot} que dado un término $U$ sin anotaciones verifica:
\begin{itemize}
  \item \xbf{Correción:} $\w{U} = \Gamma \rhd M : \sigma$ implica
    \begin{itemize}
      \item $\erase{M} = U$
      \item $\Gamma \rhd M : \sigma$ es derivable
    \end{itemize}
  \item \xbf{Completitud:} si $\Gamma \rhd M : \sigma$ es derivable y $\erase{M} = U$, entonces
    \begin{itemize}
      \item \w{U} tiene éxito y,
      \item produce un juicio $\Gamma' \rhd M' : \sigma'$ tal que $\Gamma \rhd M : \sigma$ es instancia del mismo. Se dice que \w{\cdot} computa un \xbf{tipo principal}.
    \end{itemize}
\end{itemize}

\subsubsection{Unificación}

La idea de nuestro algoritmo de inferencia va a ser analizar un término (sin anotaciones de tipo) a partir de sus subtérminos. El problema es que, una vez obtenida la información inferida de los subterminos, debemos:
\begin{itemize}
  \item \xbf{Consistencia:} determinas si la información de cada subtérmino es consistente.
  \item \xbf{Síntesis:} sintetizar la información del término original a partir de la información de los subterminos. Esto involucra \xit{compatibilizar} o \xit{unificar} la información de tipos cuando dos subtérminos tienen una misma variable.
\end{itemize}

El proceso de determinar si existe un sustitución $S$ tal que dos expresiones de tipos $\sigma$, $\tau$ son unificables (i.e. $S\sigma = S\tau$) se llama \xbf{unificación}.

\paragraph{Algunas propiedades de sustituciones}

\begin{itemize}
  \item \xbf{Composición:} $(S \circ T)(\sigma) = S(T(\sigma))$
  \item \xbf{Igualdad:} $S = T$ si tienen el mismo soporte y $St = Tt$ para todo $t$ en el soporte de $S$
  \item $S \circ Id = Id \circ S = S$
  \item $S \circ (T \circ U) = (S \circ T) \circ U$
  \item Una sustitución $S$ es \xbf{más general} que $T$ si existe $U$ tal que $T = U \circ S$.
\end{itemize}

\paragraph{Unificador más general (MGU)}

Una ecuación de unificación es una expresión de la forma $\sigma_1 \uni \sigma_2$. Una sustitución $S$ es una solución de un conjunto de ecuaciones de unificación $\{\sigma_1 \uni \sigma_1', \dots, \sigma_n \uni \sigma_n'\}$ si $S\sigma_i = S\sigma_i'$.

Una sustitución $S$ es un \xbf{MGU} de $\{\sigma_1 \uni \sigma_1', \dots, \sigma_n \uni \sigma_n'\}$ si
\begin{itemize}
  \item Es solución de $\{\sigma_1 \uni \sigma_1', \dots, \sigma_n \uni \sigma_n'\}$
  \item Es más general que cualquier otra solución de $\{\sigma_1 \uni \sigma_1', \dots, \sigma_n \uni \sigma_n'\}$
\end{itemize}

\paragraph{Algoritmo de unificación de Martelli-Montanari}

\begin{teo}
  Si $\{\sigma_1 \uni \sigma_1', \dots, \sigma_n \uni \sigma_n'\}$ tiene solución, existe un MGU y además es único salvo renombre de variables.
\end{teo}

El algoritmo de Martelli-Montanari es un algoritmo de unificación no-determinístico. Consiste en reglas de simplificación que reescriben conjuntos de pares de tipos a unificar (\xit{goals}).

\[G_0 \unito G_1 \unito_{S_1} \unito G_2 \unito \dots \unito_{S_k} G_n\]

Las secuencias que terminan en el goal vació son exitosas. Si la secuencia es exitosa el MGU es $S_k \circ \dots \circ S_1$.

Las reglas de este algoritmo son:

\begin{enumerate}
  \item \xbf{Descomposición:} $\{\sigma_1\to\sigma_2 \uni \tau_1\to\tau_2\} \cup G \unito \{\sigma_1 \uni \tau_1, \sigma_2 \uni \tau_2\} \cup G$
  \item \xbf{Eliminación de par trivial:} $\{s \uni s\} \cup G \unito G$
  \item \xbf{Swap:} si $\sigma$ no es una variable, $\{\sigma \uni s\} \cup G \unito \{s \uni \sigma\} \cup G$
  \item \xbf{Eliminación de variable:} $\{s \uni \sigma\} \cup G \unito_{\sigma/s} G[\sigma/s]$
  \item \xbf{Falla:} $\{\sigma \uni \tau\} \cup G \unito \text{falla}$, con $(\sigma, \tau) \in T \cup T^{-1}$ y $T = \{(Boo, Nat), (Nat, \sigma_1 \to \sigma_2), (Bool, \sigma_1 \to \sigma_2)\}$,
  \item \xbf{Occur check:} si $s \neq \sigma$ y $s \in FV(\sigma)$, entonces $\{s \uni \sigma\} \cup G \unito \text{falla}$
\end{enumerate}

\begin{teo}
  Propiedades del algoritmo
  \begin{itemize}
    \item El algoritmo de Martelli-Montanari siempre termina
    \item Sea $G$ un conjunto de pares
      \begin{itemize}
        \item Si $G$ tiene un unificador, el algoritmo termina exitosamente y retorna un MGU.
        \item Si $G$ no tiene unificador, el algoritmo termina con \xtt{falla}.
      \end{itemize}
    \item Tanto la unificación como la inferencia se pueden hacer en tiempo lineal. Pero el tipo asociado a un término sin anotaciones puede ser exponencial en el tamaño del término.
  \end{itemize}
\end{teo}

\subsubsection{Algoritmo de inferencia}

El algoritmo que vamos a presentar se basa en definir \w{U} por recursión sobre la estructura de U, y utiliza el algoritmo de unificación para ir sintetizando la información de las subexpresiones de $U$.

\paragraph{Caso constantes y variables}

\begin{align*}
  \w{0} &\eqdef \emptyset \rhd 0 : Nat \\
  \w{true} &\eqdef \emptyset \rhd true : Bool \\
  \w{false} &\eqdef \emptyset \rhd false : Bool \\
  \w{x} &\eqdef \{x:s\} \rhd x : s \text{, con $s$ variable fresca} \\
\end{align*}

\paragraph{Caso succ}

\begin{itemize}
  \item Sea $\w{U} = \Gamma \rhd M : \tau$
  \item Sea $S = MGU\{\tau \uni Nat\}$
  \item Entonces
  \[\w{succ(U)} \eqdef S\Gamma \rhd S\ succ(M) : Nat\]
\end{itemize}

El caso de $pred$ es similar.

\paragraph{Caso iszero}

\begin{itemize}
  \item Sea $\w{U} = \Gamma \rhd M : \tau$
  \item Sea $S = MGU\{\tau \uni Nat\}$
  \item Entonces
  \[\w{iszero(U)} \eqdef S\Gamma \rhd S\ iszero(M) : Bool\]
\end{itemize}

\paragraph{Caso ifThenElse}

\begin{itemize}
  \item Sea
    \begin{itemize}
      \item $\w{U} = \Gamma_1 \rhd M : \rho$
      \item $\w{V} = \Gamma_2 \rhd P : \sigma$
      \item $\w{W} = \Gamma_3 \rhd Q : \tau$
    \end{itemize}
\end{itemize}

\todo{TERMINAR DE ESCRIBIR LOS CASOS DEL ALGORITMO}
