\section{Paradigma Funcional}

\subsection{Características generales}

\begin{itemize}
  \item Computación expresada a través de la aplicación y composición de funciones.
  \item No hay un estado global.
  \item Los estados intermedios (salidas de las funciones) son pasados directamente a otras funciones como argumentos.
  \item Repetición basada en recursión.
  \item Expresiones tipadas.
  \item Tine un \xbf{alto nivel de abstracción}: tiende a ser una \xit{especificación ejecutable}.
  \item Es \xbf{declarativo}: la máquina se encarga de buscar el \xit{cómo} y nosotros elegimos el \xit{qué}.
  \item La matemática y razonamiento algebraico tienden a ser más elegantes.
  \item En el pasado: ejecución más lenta. Hoy en día no está tan claro que sea así.
\end{itemize}

\subsection{Haskell}

\subsubsection{Repaso}

\begin{itemize}
  \item La evaluación consiste en aplicar ecuaciones (orientadas de izquierda a derecha).
  \item Definición de funciones por casos.
  \item Tipos básicos: \xtt{Int}, \xtt{Bool}, \xtt{Float}, \xtt{Pares}, \xtt{Listas}, \xtt{Funciones}, etc.
  \item No toda evaluación termina.
  \item Utiliza evaluación \xit{Lazy o Normal}: una subexpresión se evalua sólo si es necesario.
  \item Polimorfismo párametrico.
  \item Alto orden
  \item Currificación
\end{itemize}

\subsubsection{Esquemas de recursion}

map y filter, etc.

\subsubsection{Monadas}

\subsection{Lambda cálculo}

Fue introducido por \xit{Alonzo Church} en 1934, y presenta un modelo de comptuación basado en \xbf{funciones}.

La formulación original es sin tipos, pero posteriormente (1941) se introduce el \xbf{Lambda cálculo tipado}, que es el que vamos a estudiar.

Empezamos con el Lambda cálculo tipado con expresiones booleanas y luego lo vamos extendiendo con otras construcciones.

\subsubsection{Expresiones de tipos}

Denotan los diferentes \xbf{tipos}. Por ejemplo, en el Lambda cálculo tipado con expresiones booleanas (de ahora en más $\lambda^b$) tenemos:

\[ \sigma, \tau ::= Bool|\sigma\to\tau \]

dónde,
\begin{itemize}
  \item $Bool$ es el tipo de los booleanos,
  \item $\sigma\to\tau$ es el tipo de las funciones de tipo $\sigma$ en $\tau$,
  \item con $\sigma$ y $\tau$ dos tipos (no necesariamente distintos).
\end{itemize}

\subsubsection{Términos}

Denotan las posibles expresiones que podemos construir. Por ejemplo, en $\lambda^b$ tenemos:

\[ M ::= true \vert false \vert \ifte{M}{P}{Q} \vert \app{M}{N} \vert \abs{x}{\sigma}{M} \vert x \]

dónde,
\begin{itemize}
  \item $true$ y $false$ son las constantes de verdad,
  \item \ifte{M}{P}{Q} es el condicional,
  \item \app{M}{N} es la aplicación de la función denotada por el término $M$ al argumento $N$,
  \item \abs{x}{\sigma}{M} es una función cuyo parámetro formal es $x$ y cuyo cuerpo es $M$.
  \item $x$ es una variable de términos.
\end{itemize}

Ejemplo: $\app{(\abs{f}{Bool \to Bool}{f\ true})}{(\abs{y}{Bool}{y})}$

\subsubsection{Sustitución}

Dentro de un término, una variable puede estar \xbf{libre} o \xbf{ligada}. Decimos que $x$ ocurre libre si no se encuentra bajo el alcance de una ocurrencia de $\lambda x$. En caso contrario, está ligada. Formalmente, tenemos que:

\begin{align*}
FV(x) &\eqdef \{x\} \\
FV(true) = FV (false) &\eqdef \emptyset \\
FV(\ifte{M}{P}{Q}) &\eqdef FV(M) \cup FV(P) \cup FV(Q) \\
FV(\app{M}{N}) &\eqdef FV(M) \cup FV(N) \\
FV(\abs{x}{\sigma}{M}) &\eqdef FV(M)\ \backslash\ \{x\} \\
\end{align*}

Luego, el proceso de sustitución $M\{x \from N\}$ consiste en sustituir todas las ocurrencias \xit{libres} de $x$ en el término $M$ por el término $N$. Esto se utilizar para darle semántica a la aplicación de funciones.

Cuando realizamos este proceso, asumimos que la variable ligada se renombró de tal manera que no ocurre libre en $N$. Por ejemplo:

\[ \sust{\abs{z}{\sigma}{x}}{x\from Z} = \abs{z}{\sigma}{z}\]

Está mal, ya que convertimos la función constante \abs{z}{\sigma}{x} en la función identidad. Entonces, deberíamos haber utilizado:

\[ \sust{\abs{w}{\sigma}{x}}{x\from Z} = \abs{w}{\sigma}{z}\]

Una vez que entendemos esto, podemos definir el concepto de $\alpha-equivalencia$. Decimos que dos términos $M$ y $N$ son $\alpha-equivalentes$ si difieren solamente en el nombre de sus variables ligadas. Ejemplo: $\abs{z}{Bool}{z} =_{\alpha} \abs{y}{Bool}{y}$, pero $\abs{x}{Bool}{y} \neq_{\alpha} \abs{x}{Bool}{z}$.

En los casos de sustitución que haya conflictos, podemos renombrar apropiadamente para que ande todo.

\subsubsection{Sistema de tipado}

Es un sistema formal de deducción (o derivación) que utiliza axiomas y reglas de tipado para caracterizar un subconjunto de los términos llamados \xit{tipados}. Es decir, es un sistema mediante el cual podemos deducir el tipo de un término.

Un \xit{contexto de tipado} $\Gamma$ es un conjunto de pares $\{x_1:\sigma_1,\dots,x_n:\sigma_n\}$ donde cada $x_i$ es distinto. Los $x_i$ representan las variables y los $\sigma_i$ sus tipo asignado.

Un \xit{juicio de tipado} es una expresión de la forma $\Gamma \rhd M : \sigma$ que significa que el término $M$ tiene tipo $\sigma$ asumiendo el contexto de tipado $\Gamma$. Estos juicios se generan utilizando \xit{axiomas y reglas de tipado}. Ejemplo de axioma:

\[\deriv{}{\Gamma \rhd true : Bool}{T-True}\]

Ejemplo de regla:

\[\deriv{\Gamma, x : \sigma \rhd M : \tau}{\Gamma \rhd \abs{x}{\sigma}{M}:\sigma\to\tau}{T-Abs}\]

\vspace{0.5em}
Entonces, $M$ es \xit{tipable}  si $\Gamma \rhd M : \sigma$ puede derivarse usando los axiomas y reglas de tipados, para algún $\Gamma$ y $\sigma$.

\paragraph{Propiedades básicas:}

\begin{itemize}
  \item \xbf{Unicidad de tipos}: si $\Gamma \rhd M : \sigma$ y $\Gamma \rhd M : \tau$ son derivables, entonces $\sigma = \tau$.
  \item \xbf{Weakening+Strenghening}: si $\Gamma \rhd M : \sigma$ es derivable y $\Gamma \cap \Gamma'$ contiene a todas las variables libres de $M$, entonces $\Gamma' \rhd M : \sigma$.
  \item \xbf{Sustitución}: si $\Gamma,x:\sigma \rhd M : \tau$ y $\Gamma \rhd N : \sigma$ son derivables, entonces $\Gamma \rhd \sust{M}{x\from N} : \tau$ es derivable.
\end{itemize}

\subsubsection{Semántica operacional}

Habiendo definido la sintaxis de $\lambda^b$, nos interesa formular cómo se evalúan o ejecutan los términos. Esto se puede hacer de varias formas: operacional, denotacional y axiomática. Nosotros vamos a user \xit{operacional}.

La semántica operacional consiste en interpretar a los \xit{términos como estados} de una máquina abstracta y definir una \xit{función de transición} que indica, dado un estado, cúal es el estado siguiente. De esta forma, el \xit{significado} de un término $M$ es el estado final que alcanza la máquina empezando desde $M$. Hay principalmente dos formas de definir la función de transición:

\begin{itemize}
  \item \xbf{Small-step}: la función de transición describe un paso de computación.
  \item \xbf{Big-step}: la función de transición, en un paso, evalúa el término a su resultado.
\end{itemize}

Al igual que con el Sistema de tipado, vamos a usar axiomas y reglas para formular \xbf{juicios de evaluación} $M\to N$ que indican que el término $M$ reduce, en un paso, al término $N$. Ejemplo de axioma:

\[\deriv{}{\ifte{true}{M_2}{M_3} \to M_2}{E-IfTrue}\]

Ejemplo de regla:

\[\deriv{M_1 \to M_1'}{\ifte{M_1}{M_2}{M_3} \to \ifte{M_1'}{M_2}{M_3}}{E-If}\]

Cuando dado un término $M$, no existe $N$ tal que $M\to N$, decimos que $M$ no puede reducirse más y está en \xbf{forma normal}.

Lo último que nos falta agregar es un conjunto de \xbf{Valores} que denota las expresiones que pueden ser un resultado válido de un cómputo. Para $\lambda^b$, tenemos que $V ::= true \vert false$.

\paragraph{Propiedades básicas:}

\begin{itemize}
  \item \xbf{Determinismo del juicio de evaluación en un paso}: si $M \to M'$ y $M \to M''$, entonces $M'= M''$.
  \item Todo valor está en forma normal, pero no vale el recíproco.
  \item Si un termino está en forma normal pero no es un valor, entonces decimos que es un \xbf{estado de error}.
\end{itemize}

\noindent
El \xbf{Juicio de evaluación en muchos pasos} $\toto$ es la clausura reflexiva, transitiva de $\to$. Es decir, la menor relación tal que:

\begin{itemize}
  \item Si $M\to M'$, entonces $M\toto M'$.
  \item $M\toto M$, para todo $M$.
  \item Si $M \toto M'$ y $M' \toto M''$, entonces $M \toto M''$.
\end{itemize}

\paragraph{Propiedades de evaluación en muchos pasos:}

\begin{itemize}
  \item \xbf{Unicidad de formas normales}: si $M \toto _U$ y $M \toto V$, entonces $U=V$.
  \item \xbf{Terminación}: para todo $M$ existe una forma normal $N$ tal que $M \toto N$.
  \item Si un término está bien tipado, y termina, entonces evalúa a un valor.
\end{itemize}

\paragraph{Propiedades de \xit{Corrección}:}

\begin{itemize}
  \item Corrección = Progreso + Preservación.
  \item \xbf{Progreso}: si $M$ es cerrado y bien tipado entonces
    \begin{itemize}
      \item $M$ es un valor
      \item o bien existe $M'$ tal que $M \to M'$.
    \end{itemize}
    Esto quiere decir que la evaluación no puede trabarse para términos cerrados y bien tipados que no son valores.
  \item \xbf{Preservación}: si $\Gamma \rhd M : \sigma$ y $M \to N$, entonces $\Gamma \rhd N : \sigma$. Es decir que la evaluación preserva tipos.
\end{itemize}

\subsubsection{Extensiones}

\begin{itemize}
  \item $\lambda^{bn}$: tiene $Bool$, $Nat$ y funciones.
  \item Registros
  \item Declaraciones locales
  \item Referencias
  \item Recursión
\end{itemize}

\subsubsection{Inferencia de tipos}

Es un procedimiento que consiste en transformar términos \xit{sin} información de tipos en términos \xbf{tipables}. Para ello, debemos inferir la información de tipos faltante. Esto trae como beneficios:

\begin{itemize}
  \item El programador puede obviar algunas declaraciones de tipos.
  \item En general, evita la sobrecarga de tener que declarar y manipular \xit{todos} los tipos.
  \item Todo ello sin impactar la perfomance del programa: la inferencia de tipos se realiza en tiempo de compilación.
\end{itemize}

\paragraph{Función de borrado}

LLamamos \erase{\cdot} a la función que dado un término \xit{elimina} las anotaciones de tipos de las abstracciones. Ejemplo: $\erase{\abs{x}{Nat}{\abs{f}{Nat\to Nat}{f\ x}}} = \stabs{x}{\stabs{f}{f\ x}}$

Entonces queremos, dado un término $U$ \xit{sin} anotaciones de tipos, hallar un término estándar $M$ tal que:
\begin{itemize}
  \item $\Gamma \rhd M : \sigma$, para algún $\Gamma$ y $\sigma$, y
  \item $\erase{M} = U$
\end{itemize}

Notar que este problema es más difícil que el chequeo de tipos para un término estandar $M$ que haciamos utilizando los axiomas y reglas del sistema de tipado.

\paragraph{Variables de tipos}

Para poder escribir una \xit{única} expresión que englobe muchas soluciones de inferencia vamos a usar variables de tipo.

Dichas variables las vamos a representar con la letra ``\xit{s}''. Si tenemos una expresión que utiliza \xit{s}, basta con sustituir \xit{s} por cualquier expresión de tipos para arrojar una solución válida.

\paragraph{Sustitución de tipos}

Es una función $S$ o $T$ que mapea variables de tipo en expresiones de tipo. Entonces, nuestra función de sustitución $S$ puede aplicarse a:
\begin{itemize}
  \item Una expresión de tipos $\sigma$ (escribimos $S\sigma$)
  \item Una término $M$ $\sigma$ (escribimos $SM$)
  \item Un contexto de tipado  $\Gamma = \{x_1:\sigma_1,\dots,x_n:\sigma_n\}$ (escribimos $S\Gamma$) y se define como $S\Gamma \eqdef \{x_1:S\sigma_1,\dots,x_n:S\sigma_n\}$
\end{itemize}

Notas sobre la sustitución:

\begin{itemize}
  \item El conjunto $\{t\ |\ St \neq t\}$ se llama \xbf{soporte} de $S$. Este conjunto representa las variables que $S$ ``afecta''.
  \item Usamos la notación $\{\sigma_1/t_1,\dots,\sigma_n/t_n\}$ para la sustitución con soporte $\{t_1,\dots,t_n\}$.
  \item La sustitución cuyo soporte es $\emptyset$ es la sustitución identidad (\xit{Id}).
\end{itemize}

\paragraph{Instancia de un juicio de tipado}

Un juicio de tipado $\Gamma' \rhd M' : \sigma'$ es una instancia de $\Gamma \rhd M : \sigma$ si existe una substitución de tipos $S$ tal que $S\Gamma \subset \Gamma'$, $M' = SM$ y $\sigma' = S\sigma$. Como propiedad: si $\Gamma \rhd M : \sigma$ es derivable, entonces cualquier instancia del mismo también lo es.

\paragraph{Función de inferencia \w{\cdot}}

Entonces, queremos definir una función \w{\cdot} que dado un término $U$ sin anotaciones verifica:
\begin{itemize}
  \item \xbf{Correción:} $\w{U} = \Gamma \rhd M : \sigma$ implica
    \begin{itemize}
      \item $\erase{M} = U$
      \item $\Gamma \rhd M : \sigma$ es derivable
    \end{itemize}
  \item \xbf{Completitud:} si $\Gamma \rhd M : \sigma$ es derivable y $\erase{M} = U$, entonces
    \begin{itemize}
      \item \w{U} tiene éxito y,
      \item produce un juicio $\Gamma' \rhd M' : \sigma'$ tal que $\Gamma \rhd M : \sigma$ es instancia del mismo. Se dice que \w{\cdot} computa un \xbf{tipo principal}.
    \end{itemize}
\end{itemize}

\subsubsection{Unificación}

La idea de nuestro algoritmo de inferencia va a ser analizar un término (sin anotaciones de tipo) a partir de sus subtérminos. El problema es que, una vez obtenida la información inferida de los subterminos, debemos:
\begin{itemize}
  \item \xbf{Consistencia:} determinas si la información de cada subtérmino es consistente.
  \item \xbf{Síntesis:} sintetizar la información del término original a partir de la información de los subterminos. Esto involucra \xit{compatibilizar} o \xit{unificar} la información de tipos cuando dos subtérminos tienen una misma variable.
\end{itemize}

El proceso de determinar si existe un sustitución $S$ tal que dos expresiones de tipos $\sigma$, $\tau$ son unificables (i.e. $S\sigma = S\tau$) se llama \xbf{unificación}.

\paragraph{Algunas propiedades de sustituciones}

\begin{itemize}
  \item \xbf{Composición:} $(S \circ T)(\sigma) = S(T(\sigma))$
  \item \xbf{Igualdad:} $S = T$ si tienen el mismo soporte y $St = Tt$ para todo $t$ en el soporte de $S$
  \item $S \circ Id = Id \circ S = S$
  \item $S \circ (T \circ U) = (S \circ T) \circ U$
  \item Una sustitución $S$ es \xbf{más general} que $T$ si existe $U$ tal que $T = U \circ S$.
\end{itemize}

\paragraph{Unificador más general (MGU)}

Una ecuación de unificación es una expresión de la forma $\sigma_1 \uni \sigma_2$. Una sustitución $S$ es una solución de un conjunto de ecuaciones de unificación $\{\sigma_1 \uni \sigma_1', \dots, \sigma_n \uni \sigma_n'\}$ si $S\sigma_i = S\sigma_i'$.

Una sustitución $S$ es un \xbf{MGU} de $\{\sigma_1 \uni \sigma_1', \dots, \sigma_n \uni \sigma_n'\}$ si
\begin{itemize}
  \item Es solución de $\{\sigma_1 \uni \sigma_1', \dots, \sigma_n \uni \sigma_n'\}$
  \item Es más general que cualquier otra solución de $\{\sigma_1 \uni \sigma_1', \dots, \sigma_n \uni \sigma_n'\}$
\end{itemize}

\paragraph{Algoritmo de unificación de Martelli-Montanari}

\begin{teo}
  Si $\{\sigma_1 \uni \sigma_1', \dots, \sigma_n \uni \sigma_n'\}$ tiene solución, existe un MGU y además es único salvo renombre de variables.
\end{teo}

El algoritmo de Martelli-Montanari es un algoritmo de unificación no-determinístico. Consiste en reglas de simplificación que reescriben conjuntos de pares de tipos a unificar (\xit{goals}).

\[G_0 \unito G_1 \unito_{S_1} \unito G_2 \unito \dots \unito_{S_k} G_n\]

Las secuencias que terminan en el goal vació son exitosas. Si la secuencia es exitosa el MGU es $S_k \circ \dots \circ S_1$.

Las reglas de este algoritmo son:

\begin{enumerate}
  \item \xbf{Descomposición:} $\{\sigma_1\to\sigma_2 \uni \tau_1\to\tau_2\} \cup G \unito \{\sigma_1 \uni \tau_1, \sigma_2 \uni \tau_2\} \cup G$
  \item \xbf{Eliminación de par trivial:} $\{s \uni s\} \cup G \unito G$
  \item \xbf{Swap:} si $\sigma$ no es una variable, $\{\sigma \uni s\} \cup G \unito \{s \uni \sigma\} \cup G$
  \item \xbf{Eliminación de variable:} $\{s \uni \sigma\} \cup G \unito_{\sigma/s} G[\sigma/s]$
  \item \xbf{Falla:} $\{\sigma \uni \tau\} \cup G \unito \text{falla}$, con $(\sigma, \tau) \in T \cup T^{-1}$ y $T = \{(Boo, Nat), (Nat, \sigma_1 \to \sigma_2), (Bool, \sigma_1 \to \sigma_2)\}$,
  \item \xbf{Occur check:} si $s \neq \sigma$ y $s \in FV(\sigma)$, entonces $\{s \uni \sigma\} \cup G \unito \text{falla}$
\end{enumerate}

\begin{teo}
  Propiedades del algoritmo
  \begin{itemize}
    \item El algoritmo de Martelli-Montanari siempre termina
    \item Sea $G$ un conjunto de pares
      \begin{itemize}
        \item Si $G$ tiene un unificador, el algoritmo termina exitosamente y retorna un MGU.
        \item Si $G$ no tiene unificador, el algoritmo termina con \xtt{falla}.
      \end{itemize}
    \item Tanto la unificación como la inferencia se pueden hacer en tiempo lineal. Pero el tipo asociado a un término sin anotaciones puede ser exponencial en el tamaño del término.
  \end{itemize}
\end{teo}

\subsubsection{Algoritmo de inferencia}

El algoritmo que vamos a presentar se basa en definir \w{U} por recursión sobre la estructura de U, y utiliza el algoritmo de unificación para ir sintetizando la información de las subexpresiones de $U$.

\paragraph{Caso constantes y variables}

\begin{align*}
  \w{0} &\eqdef \emptyset \rhd 0 : Nat \\
  \w{true} &\eqdef \emptyset \rhd true : Bool \\
  \w{false} &\eqdef \emptyset \rhd false : Bool \\
  \w{x} &\eqdef \{x:s\} \rhd x : s \text{, con $s$ variable fresca} \\
\end{align*}

\paragraph{Caso succ}

\begin{itemize}
  \item Sea $\w{U} = \Gamma \rhd M : \tau$
  \item Sea $S = MGU\{\tau \uni Nat\}$
  \item Entonces
  \[\w{succ(U)} \eqdef S\Gamma \rhd S\ succ(M) : Nat\]
\end{itemize}

El caso de $pred$ es similar.

\paragraph{Caso iszero}

\begin{itemize}
  \item Sea $\w{U} = \Gamma \rhd M : \tau$
  \item Sea $S = MGU\{\tau \uni Nat\}$
  \item Entonces
  \[\w{iszero(U)} \eqdef S\Gamma \rhd S\ iszero(M) : Bool\]
\end{itemize}

\paragraph{Caso ifThenElse}

\begin{itemize}
  \item Sea
    \begin{itemize}
      \item $\w{U} = \Gamma_1 \rhd M : \rho$
      \item $\w{V} = \Gamma_2 \rhd P : \sigma$
      \item $\w{W} = \Gamma_3 \rhd Q : \tau$
    \end{itemize}
\end{itemize}

TERMINAR DE ESCRIBIR LOS CASOS DEL ALGORITMO
